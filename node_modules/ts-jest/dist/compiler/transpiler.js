"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var compiler_utils_1 = require("./compiler-utils");
exports.initializeTranspilerInstance = function (configs, memoryCache, logger) {
    logger.debug('initializeTranspilerInstance(): create typescript compiler');
    var _a = configs.parsedTsConfig, options = _a.options, projectReferences = _a.projectReferences, fileNames = _a.fileNames;
    var ts = configs.compilerModule;
    var program = projectReferences
        ? ts.createProgram({
            rootNames: fileNames,
            options: options,
            projectReferences: projectReferences,
        })
        : ts.createProgram([], options);
    var updateFileInCache = function (contents, filePath) {
        var file = memoryCache.files.get(filePath);
        if (file && file.text !== contents) {
            file.version++;
            file.text = contents;
        }
    };
    return {
        compileFn: function (code, fileName) {
            updateFileInCache(code, fileName);
            var referencedProject = compiler_utils_1.getAndCacheProjectReference(fileName, program, memoryCache.files, projectReferences);
            if (referencedProject !== undefined) {
                logger.debug({ fileName: fileName }, 'compileFn(): get compile result from referenced project');
                return compiler_utils_1.getCompileResultFromReferencedProject(fileName, configs, memoryCache.files, referencedProject);
            }
            else {
                logger.debug({ fileName: fileName }, 'compileFn(): compiling as isolated module');
                var result = ts.transpileModule(code, {
                    fileName: fileName,
                    transformers: configs.tsCustomTransformers,
                    compilerOptions: options,
                    reportDiagnostics: configs.shouldReportDiagnostic(fileName),
                });
                if (result.diagnostics && configs.shouldReportDiagnostic(fileName)) {
                    configs.raiseDiagnostics(result.diagnostics, fileName, logger);
                }
                return [result.outputText, result.sourceMapText];
            }
        },
        program: program,
    };
};
