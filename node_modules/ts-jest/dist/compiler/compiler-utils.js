"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var micromatch = require("micromatch");
var path_1 = require("path");
var _ts = require("typescript");
var constants_1 = require("../constants");
var sha1_1 = require("../util/sha1");
function getResolvedModulesCache(cacheDir) {
    return path_1.join(cacheDir, sha1_1.sha1('ts-jest-resolved-modules', '\x00'));
}
exports.getResolvedModulesCache = getResolvedModulesCache;
function cacheResolvedModules(fileName, fileContent, memoryCache, program, cacheDir, logger) {
    var importReferences = program.getSourceFile(fileName).imports;
    if (importReferences.length) {
        logger.debug({ fileName: fileName }, 'cacheResolvedModules(): get resolved modules');
        memoryCache.resolvedModules[fileName] = Object.create(null);
        memoryCache.resolvedModules[fileName].modulePaths = importReferences
            .filter(function (importReference) { var _a; return (_a = importReference.parent.parent.resolvedModules) === null || _a === void 0 ? void 0 : _a.get(importReference.text); })
            .map(function (importReference) {
            return path_1.normalize(importReference.parent.parent.resolvedModules.get(importReference.text)
                .resolvedFileName);
        })
            .reduce(function (a, b) { return a.concat(b); }, []);
        memoryCache.resolvedModules[fileName].testFileContent = fileContent;
        fs_1.writeFileSync(getResolvedModulesCache(cacheDir), JSON.stringify(memoryCache.resolvedModules));
    }
}
exports.cacheResolvedModules = cacheResolvedModules;
function isTestFile(testMatchPatterns, fileName) {
    return testMatchPatterns.some(function (pattern) {
        return typeof pattern === 'string' ? micromatch.isMatch(fileName, pattern) : pattern.test(fileName);
    });
}
exports.isTestFile = isTestFile;
function isUsingProjectReferences(program, projectReferences) {
    if (projectReferences && !!program.getProjectReferences) {
        return Boolean(program && program.getProjectReferences());
    }
    return false;
}
function getResolvedProjectReferences(program) {
    var _a;
    var getProjectReferences = (_a = program.getResolvedProjectReferences) !== null && _a !== void 0 ? _a : program.getProjectReferences;
    if (getProjectReferences) {
        return getProjectReferences();
    }
    return;
}
function getProjectReferenceForFile(filePath, program, projectReferences) {
    if (isUsingProjectReferences(program, projectReferences)) {
        return (program &&
            getResolvedProjectReferences(program).find(function (ref) { return (ref && ref.commandLine.fileNames.some(function (file) { return path_1.normalize(file) === filePath; })) || false; }));
    }
    return;
}
function getAndCacheProjectReference(filePath, program, files, projectReferences) {
    var file = files.get(filePath);
    if (file === null || file === void 0 ? void 0 : file.projectReference) {
        return file.projectReference.project;
    }
    var projectReference = getProjectReferenceForFile(filePath, program, projectReferences);
    if (file !== undefined) {
        file.projectReference = { project: projectReference };
    }
    return projectReference;
}
exports.getAndCacheProjectReference = getAndCacheProjectReference;
function getOutputJavaScriptFileName(inputFileName, projectReference) {
    var options = projectReference.commandLine.options;
    var projectDirectory = options.rootDir || path_1.dirname(projectReference.sourceFile.fileName);
    var relativePath = path_1.relative(projectDirectory, inputFileName);
    var outputPath = path_1.resolve(options.outDir || projectDirectory, relativePath);
    var newExtension = constants_1.JSON_REGEX.test(inputFileName)
        ? '.json'
        : constants_1.TS_TSX_REGEX.test(inputFileName) && options.jsx === _ts.JsxEmit.Preserve
            ? '.jsx'
            : '.js';
    return outputPath.replace(constants_1.EXTENSION_REGEX, newExtension);
}
function getAndCacheOutputJSFileName(inputFileName, projectReference, files) {
    var _a, _b;
    var file = files.get(inputFileName);
    if ((_a = file === null || file === void 0 ? void 0 : file.projectReference) === null || _a === void 0 ? void 0 : _a.outputFileName) {
        return file.projectReference.outputFileName;
    }
    var outputFileName = getOutputJavaScriptFileName(inputFileName, projectReference);
    if (file !== undefined) {
        file.projectReference = (_b = file.projectReference) !== null && _b !== void 0 ? _b : {
            project: projectReference,
        };
        file.projectReference.outputFileName = outputFileName;
    }
    return outputFileName;
}
function getCompileResultFromReferencedProject(fileName, configs, files, referencedProject) {
    var _a = __read([
        configs.resolvePath(referencedProject.sourceFile.fileName),
        configs.resolvePath(fileName),
    ], 2), relativeProjectConfigPath = _a[0], relativeFilePath = _a[1];
    if (referencedProject.commandLine.options.outFile !== undefined) {
        throw new Error("The referenced project at " + relativeProjectConfigPath + " is using " +
            "the outFile' option, which is not supported with ts-jest.");
    }
    var jsFileName = getAndCacheOutputJSFileName(fileName, referencedProject, files);
    var relativeJSFileName = configs.resolvePath(jsFileName);
    if (!configs.compilerModule.sys.fileExists(jsFileName)) {
        throw new Error('Could not find output JavaScript file for input ' +
            (relativeFilePath + " (looked at " + relativeJSFileName + ").\n") +
            'The input file is part of a project reference located at ' +
            (relativeProjectConfigPath + ", so ts-jest is looking for the ") +
            'projectâ€™s pre-built output on disk. Try running `tsc --build` ' +
            'to build project references.');
    }
    var mapFileName = jsFileName + ".map";
    var outputText = configs.compilerModule.sys.readFile(jsFileName);
    var sourceMapText = configs.compilerModule.sys.readFile(mapFileName);
    return [outputText, sourceMapText];
}
exports.getCompileResultFromReferencedProject = getCompileResultFromReferencedProject;
